Grouping tokens:
---------------
( ) [ ] { }

Unary operators:
---------------
+ - ! ~ & * 

Binary operators:
----------------
LSHIFT = '<<'
RSHIFT = '>>'
EQ     = '=='
NOTEQ  = '!='
LTEQ   = '<='
GTEQ   = '>='
AND    = '&&'
OR     = '||'

+ - | ^ LSHIFT RSHIFT
* / % &
EQ NOTEQ < LTEQ > GTEQ
AND
OR

Ternary operators:
-----------------
? :

Assignment operators:
--------------------
COLON_ASSIGN  = ':='
ADD_ASSIGN    = '+='
SUB_ASSIGN    = '-='
OR_ASSIGN     = '|='
AND_ASSIGN    = '&='
XOR_ASSIGN    = '^='
LSHIFT_ASSIGN = '<<='
RSHIFT_ASSIGN = '>>='
MUL_ASSIGN    = '*='
DIV_ASSIGN    = '/='
MOD_ASSIGN    = '%='
INC           = '++'
DEC           = '--'

Names / literals:
--------------
NAME  = [a-zA-Z_][a-zA-Z0-9_]*
INT   = 0 | [1-9][0-9]* | 0[xX][0-9a-fA-F]+ | 0[0-7]+ | 0[bB][0-1]+
FLOAT = [0-9]*[.]?[0-9]*([eE][+-]?[0-9]+)?
CHAR  = '\'' . '\''
STR  = '"' [^"]* '"'

-------------------------------------------------------------------------------
                          AST S-expression format
-------------------------------------------------------------------------------

func fact(n: int): int {
    if (n == 0) {
        return 1;
    } else {
        return (n * func(n - 1));
    }
}

(func fact (n int) int
  (if (== n 0)
    (then
      (return 1))
  (else
    (return (* n (fact (- n 1)))))))

-------------------------------------------------------------------------------
                                 EBNF grammar
-------------------------------------------------------------------------------

Declarations:
------------

type_list = type (',' type)*
name_list = NAME (',' NAME)*

base_type = NAME
          | 'func' '(' type_list? ')' (':' type)?
          | '(' type ')'
type = base_type ('[' expr? ']' | '*')*

enum_item = NAME ('=' expr)?
enum_items = enum_item (',' enum_item)* ','?
enum_decl = NAME '{' enum_items? '}'

aggregate_field = name_list ':' type ';'
aggregate_decl = NAME '{' aggregate_field* '}'

var_decl = NAME '=' expr
         | NAME ':' type ('=' expr)?

const_decl = NAME '=' expr

typedef_decl NAME '=' type

func_param = NAME ':' type
func_param_list = func_param (',' func_param)*
func_decl = NAME '(' func_param_list? ')' (':' type)? stmt_block

decl = 'enum' enum_decl
     | 'struct' aggregate_decl
     | 'union' aggregate_decl
     | 'var' var_decl
     | 'const' const_decl
     | 'typedef typedef_decl
     | 'func' func_decl


Statements:
----------

assign_op = '='
          | COLON_ASSIGN
          | ADD_ASSIGN
          | SUB_ASSIGN
          | OR_ASSIGN
          | AND_ASSIGN
          | XOR_ASSIGN
          | LSHIFT_ASSIGN
          | RSHIFT_ASSIGN
          | MUL_ASSIGN
          | DIV_ASSIGN
          | MOD_ASSIGN

switch_case = (CASE expr | DEFAULT) ':' stmt*
switch_block = '{' switch_case* '}'

stmt = 'return' expr ';'
     | 'break' ';'
     | 'continue' ';'
     | 'if' '(' expr ')' stmt_block ('else' 'if' '(' expr ')' stmt_block)* ('else' stmt_block)*
     | 'while' '(' expr ')' stmt_block
     | 'for' '(' stmt_list ';' expr ';' stmt_list ')' stmt_block
     | 'do' stmt_block 'while' '(' expr ')' ';'
     | '{' stmt* '};
     | 'switch' '(' expr ')' switch_block
     | expr (INC | DEC | assign_op expr)? 


Expressions:
-----------

typespec = NAME | '(' ':' type ')'

operand_expr = INT
             | FLOAT
             | STR
             | NAME
             | typespec? '{' expr_list '}'
             | CAST '(' type ')' expr
             | '(' expr ')'
base_expr = operand_expr ('(' expr_list ')' | '[' expr ']' | '.' NAME)*
unary_expr = [+-&*]unary_expr
           | base_expr

mul_op = '*' | '/' | '%' | & | LSHIFT | RSHIFT
mul_expr = unary_expr (mul_op unary_expr)*
add_op = '+' | '-' | '|' | '^'
add_expr = mul_expr (add_op mul_expr)*
cmp_op = EQ | NOTEQ | < | LTEQ | > | GTEQ
cmp_expr = mul_expr (cmp_op mul_expr)*
and_expr = cmp_expr (AND cmp_expr)*
or_expr = and_expr (OR and_expr)*
ternary_expr = or_expr('?' ternary_expr ':' ternary_expr)?
expr = ternary_expr
